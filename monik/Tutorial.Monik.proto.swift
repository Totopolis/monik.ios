// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "monik.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tutorial { }

public extension Tutorial {
  public struct MonikRoot {
    public static let `default` = MonikRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
  }



  //Enum type declaration start 

  public enum LevelType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case system = 0
    case application = 10
    case logic = 20
    case security = 30
    public func toString() -> String {
      switch self {
      case .system: return "SYSTEM"
      case .application: return "APPLICATION"
      case .logic: return "LOGIC"
      case .security: return "SECURITY"
      }
    }
    public static func fromString(str:String) throws -> Tutorial.LevelType {
      switch str {
      case "SYSTEM":  return .system
      case "APPLICATION":  return .application
      case "LOGIC":  return .logic
      case "SECURITY":  return .security
      default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
      switch self {
      case .system: return ".system"
      case .application: return ".application"
      case .logic: return ".logic"
      case .security: return ".security"
      }
    }
  }

  //Enum type declaration end 



  //Enum type declaration start 

  public enum SeverityType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case fatal = 0
    case error = 10
    case warning = 20
    case info = 30
    case verbose = 40
    public func toString() -> String {
      switch self {
      case .fatal: return "FATAL"
      case .error: return "ERROR"
      case .warning: return "WARNING"
      case .info: return "INFO"
      case .verbose: return "VERBOSE"
      }
    }
    public static func fromString(str:String) throws -> Tutorial.SeverityType {
      switch str {
      case "FATAL":  return .fatal
      case "ERROR":  return .error
      case "WARNING":  return .warning
      case "INFO":  return .info
      case "VERBOSE":  return .verbose
      default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
      switch self {
      case .fatal: return ".fatal"
      case .error: return ".error"
      case .warning: return ".warning"
      case .info: return ".info"
      case .verbose: return ".verbose"
      }
    }
  }

  //Enum type declaration end 



  //Enum type declaration start 

  public enum FormatType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case plain = 0
    case json = 10
    case xml = 20
    public func toString() -> String {
      switch self {
      case .plain: return "PLAIN"
      case .json: return "JSON"
      case .xml: return "XML"
      }
    }
    public static func fromString(str:String) throws -> Tutorial.FormatType {
      switch str {
      case "PLAIN":  return .plain
      case "JSON":  return .json
      case "XML":  return .xml
      default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
      switch self {
      case .plain: return ".plain"
      case .json: return ".json"
      case .xml: return ".xml"
      }
    }
  }

  //Enum type declaration end 

  final public class Event : GeneratedMessage {

    public static func == (lhs: Tutorial.Event, rhs: Tutorial.Event) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasCreated == rhs.hasCreated) && (!lhs.hasCreated || lhs.created == rhs.created)
      fieldCheck = fieldCheck && (lhs.hasSource == rhs.hasSource) && (!lhs.hasSource || lhs.source == rhs.source)
      fieldCheck = fieldCheck && (lhs.hasInstance == rhs.hasInstance) && (!lhs.hasInstance || lhs.instance == rhs.instance)
      fieldCheck = fieldCheck && (lhs.hasKa == rhs.hasKa) && (!lhs.hasKa || lhs.ka == rhs.ka)
      fieldCheck = fieldCheck && (lhs.hasLg == rhs.hasLg) && (!lhs.hasLg || lhs.lg == rhs.lg)
      fieldCheck = fieldCheck && (lhs.hasPc == rhs.hasPc) && (!lhs.hasPc || lhs.pc == rhs.pc)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //OneOf declaration start

    public enum Msg {
      case OneOfMsgNotSet

      public func checkOneOfIsSet() -> Bool {
           switch self {
           case .OneOfMsgNotSet:
                return false
           default:
                return true
           }
      }
      case Ka(Tutorial.KeepAlive)

      public static func getKa(_ value:Msg) -> Tutorial.KeepAlive? {
           switch value {
           case .Ka(let enumValue):
                return enumValue
           default:
                return nil
           }
      }
      case Lg(Tutorial.Log)

      public static func getLg(_ value:Msg) -> Tutorial.Log? {
           switch value {
           case .Lg(let enumValue):
                return enumValue
           default:
                return nil
           }
      }
      case Pc(Tutorial.PerfCounter)

      public static func getPc(_ value:Msg) -> Tutorial.PerfCounter? {
           switch value {
           case .Pc(let enumValue):
                return enumValue
           default:
                return nil
           }
      }
    }
    //OneOf declaration end

    fileprivate var storageMsg:Event.Msg =  Event.Msg.OneOfMsgNotSet
    public func getOneOfMsg() ->  Event.Msg {
        let copyObjectMsg = storageMsg
        return copyObjectMsg
    }
    public fileprivate(set) var created:Int64 = Int64(0)
    public fileprivate(set) var hasCreated:Bool = false

    // Server, Role, Application, Service, etc
    public fileprivate(set) var source:String = ""
    public fileprivate(set) var hasSource:Bool = false

    // Instance of the source
    public fileprivate(set) var instance:String = ""
    public fileprivate(set) var hasInstance:Bool = false

    public fileprivate(set) var ka:Tutorial.KeepAlive!{
         get {
              return Event.Msg.getKa(storageMsg)
         }
         set (newvalue) {
              storageMsg = Event.Msg.Ka(newvalue)
         }
    }
    public fileprivate(set) var hasKa:Bool {
          get {
                guard let _ = Event.Msg.getKa(storageMsg) else {
                    return false
                }
                return true
          }
          set(newValue) {
          }
    }
    public fileprivate(set) var lg:Tutorial.Log!{
         get {
              return Event.Msg.getLg(storageMsg)
         }
         set (newvalue) {
              storageMsg = Event.Msg.Lg(newvalue)
         }
    }
    public fileprivate(set) var hasLg:Bool {
          get {
                guard let _ = Event.Msg.getLg(storageMsg) else {
                    return false
                }
                return true
          }
          set(newValue) {
          }
    }
    public fileprivate(set) var pc:Tutorial.PerfCounter!{
         get {
              return Event.Msg.getPc(storageMsg)
         }
         set (newvalue) {
              storageMsg = Event.Msg.Pc(newvalue)
         }
    }
    public fileprivate(set) var hasPc:Bool {
          get {
                guard let _ = Event.Msg.getPc(storageMsg) else {
                    return false
                }
                return true
          }
          set(newValue) {
          }
    }
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasCreated {
        try codedOutputStream.writeSInt64(fieldNumber: 1, value:created)
      }
      if hasSource {
        try codedOutputStream.writeString(fieldNumber: 2, value:source)
      }
      if hasInstance {
        try codedOutputStream.writeString(fieldNumber: 3, value:instance)
      }
      if hasKa {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:ka)
      }
      if hasLg {
        try codedOutputStream.writeMessage(fieldNumber: 5, value:lg)
      }
      if hasPc {
        try codedOutputStream.writeMessage(fieldNumber: 6, value:pc)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasCreated {
        serialize_size += created.computeSInt64Size(fieldNumber: 1)
      }
      if hasSource {
        serialize_size += source.computeStringSize(fieldNumber: 2)
      }
      if hasInstance {
        serialize_size += instance.computeStringSize(fieldNumber: 3)
      }
      if hasKa {
          if let varSizeka = ka?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizeka
          }
      }
      if hasLg {
          if let varSizelg = lg?.computeMessageSize(fieldNumber: 5) {
              serialize_size += varSizelg
          }
      }
      if hasPc {
          if let varSizepc = pc?.computeMessageSize(fieldNumber: 6) {
              serialize_size += varSizepc
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Tutorial.Event.Builder {
      return Tutorial.Event.classBuilder() as! Tutorial.Event.Builder
    }
    public func getBuilder() -> Tutorial.Event.Builder {
      return classBuilder() as! Tutorial.Event.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Tutorial.Event.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Tutorial.Event.Builder()
    }
    public func toBuilder() throws -> Tutorial.Event.Builder {
      return try Tutorial.Event.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Tutorial.Event) throws -> Tutorial.Event.Builder {
      return try Tutorial.Event.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasCreated {
        jsonMap["created"] = "\(created)"
      }
      if hasSource {
        jsonMap["source"] = source
      }
      if hasInstance {
        jsonMap["instance"] = instance
      }
      if hasKa {
        jsonMap["ka"] = try ka.encode()
      }
      if hasLg {
        jsonMap["lg"] = try lg.encode()
      }
      if hasPc {
        jsonMap["pc"] = try pc.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tutorial.Event {
      return try Tutorial.Event.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Tutorial.Event {
      return try Tutorial.Event.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasCreated {
        output += "\(indent) created: \(created) \n"
      }
      if hasSource {
        output += "\(indent) source: \(source) \n"
      }
      if hasInstance {
        output += "\(indent) instance: \(instance) \n"
      }
      if hasKa {
        output += "\(indent) ka {\n"
        if let outDescKa = ka {
          output += try outDescKa.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasLg {
        output += "\(indent) lg {\n"
        if let outDescLg = lg {
          output += try outDescLg.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasPc {
        output += "\(indent) pc {\n"
        if let outDescPc = pc {
          output += try outDescPc.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCreated {
               hashCode = (hashCode &* 31) &+ created.hashValue
            }
            if hasSource {
               hashCode = (hashCode &* 31) &+ source.hashValue
            }
            if hasInstance {
               hashCode = (hashCode &* 31) &+ instance.hashValue
            }
            if hasKa {
                if let hashValueka = ka?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueka
                }
            }
            if hasLg {
                if let hashValuelg = lg?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuelg
                }
            }
            if hasPc {
                if let hashValuepc = pc?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepc
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Tutorial.Event"
    }
    override public func className() -> String {
        return "Tutorial.Event"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Tutorial.Event = Tutorial.Event()
      public func getMessage() -> Tutorial.Event {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasCreated:Bool {
           get {
                return builderResult.hasCreated
           }
      }
      public var created:Int64 {
           get {
                return builderResult.created
           }
           set (value) {
               builderResult.hasCreated = true
               builderResult.created = value
           }
      }
      @discardableResult
      public func setCreated(_ value:Int64) -> Tutorial.Event.Builder {
        self.created = value
        return self
      }
      @discardableResult
      public func clearCreated() -> Tutorial.Event.Builder{
           builderResult.hasCreated = false
           builderResult.created = Int64(0)
           return self
      }
      public var hasSource:Bool {
           get {
                return builderResult.hasSource
           }
      }
      public var source:String {
           get {
                return builderResult.source
           }
           set (value) {
               builderResult.hasSource = true
               builderResult.source = value
           }
      }
      @discardableResult
      public func setSource(_ value:String) -> Tutorial.Event.Builder {
        self.source = value
        return self
      }
      @discardableResult
      public func clearSource() -> Tutorial.Event.Builder{
           builderResult.hasSource = false
           builderResult.source = ""
           return self
      }
      public var hasInstance:Bool {
           get {
                return builderResult.hasInstance
           }
      }
      public var instance:String {
           get {
                return builderResult.instance
           }
           set (value) {
               builderResult.hasInstance = true
               builderResult.instance = value
           }
      }
      @discardableResult
      public func setInstance(_ value:String) -> Tutorial.Event.Builder {
        self.instance = value
        return self
      }
      @discardableResult
      public func clearInstance() -> Tutorial.Event.Builder{
           builderResult.hasInstance = false
           builderResult.instance = ""
           return self
      }
      public var hasKa:Bool {
           get {
               return builderResult.hasKa
           }
      }
      public var ka:Tutorial.KeepAlive! {
           get {
               if kaBuilder_ != nil {
                  builderResult.ka = kaBuilder_.getMessage()
               }
               return builderResult.ka
           }
           set (value) {
               builderResult.hasKa = true
               builderResult.ka = value
           }
      }
      fileprivate var kaBuilder_:Tutorial.KeepAlive.Builder! {
           didSet {
              builderResult.hasKa = true
           }
      }
      public func getKaBuilder() -> Tutorial.KeepAlive.Builder {
        if kaBuilder_ == nil {
           kaBuilder_ = Tutorial.KeepAlive.Builder()
           builderResult.ka = kaBuilder_.getMessage()
           if ka != nil {
              try! kaBuilder_.mergeFrom(other: ka)
           }
        }
        return kaBuilder_
      }
      @discardableResult
      public func setKa(_ value:Tutorial.KeepAlive!) -> Tutorial.Event.Builder {
        self.ka = value
        return self
      }
      @discardableResult
      public func mergeKa(value:Tutorial.KeepAlive) throws -> Tutorial.Event.Builder {
        if builderResult.hasKa {
          builderResult.ka = try Tutorial.KeepAlive.builderWithPrototype(prototype:builderResult.ka).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.ka = value
        }
        builderResult.hasKa = true
        return self
      }
      @discardableResult
      public func clearKa() -> Tutorial.Event.Builder {
        kaBuilder_ = nil
        builderResult.hasKa = false
        builderResult.ka = nil
        return self
      }
      public var hasLg:Bool {
           get {
               return builderResult.hasLg
           }
      }
      public var lg:Tutorial.Log! {
           get {
               if lgBuilder_ != nil {
                  builderResult.lg = lgBuilder_.getMessage()
               }
               return builderResult.lg
           }
           set (value) {
               builderResult.hasLg = true
               builderResult.lg = value
           }
      }
      fileprivate var lgBuilder_:Tutorial.Log.Builder! {
           didSet {
              builderResult.hasLg = true
           }
      }
      public func getLgBuilder() -> Tutorial.Log.Builder {
        if lgBuilder_ == nil {
           lgBuilder_ = Tutorial.Log.Builder()
           builderResult.lg = lgBuilder_.getMessage()
           if lg != nil {
              try! lgBuilder_.mergeFrom(other: lg)
           }
        }
        return lgBuilder_
      }
      @discardableResult
      public func setLg(_ value:Tutorial.Log!) -> Tutorial.Event.Builder {
        self.lg = value
        return self
      }
      @discardableResult
      public func mergeLg(value:Tutorial.Log) throws -> Tutorial.Event.Builder {
        if builderResult.hasLg {
          builderResult.lg = try Tutorial.Log.builderWithPrototype(prototype:builderResult.lg).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.lg = value
        }
        builderResult.hasLg = true
        return self
      }
      @discardableResult
      public func clearLg() -> Tutorial.Event.Builder {
        lgBuilder_ = nil
        builderResult.hasLg = false
        builderResult.lg = nil
        return self
      }
      public var hasPc:Bool {
           get {
               return builderResult.hasPc
           }
      }
      public var pc:Tutorial.PerfCounter! {
           get {
               if pcBuilder_ != nil {
                  builderResult.pc = pcBuilder_.getMessage()
               }
               return builderResult.pc
           }
           set (value) {
               builderResult.hasPc = true
               builderResult.pc = value
           }
      }
      fileprivate var pcBuilder_:Tutorial.PerfCounter.Builder! {
           didSet {
              builderResult.hasPc = true
           }
      }
      public func getPcBuilder() -> Tutorial.PerfCounter.Builder {
        if pcBuilder_ == nil {
           pcBuilder_ = Tutorial.PerfCounter.Builder()
           builderResult.pc = pcBuilder_.getMessage()
           if pc != nil {
              try! pcBuilder_.mergeFrom(other: pc)
           }
        }
        return pcBuilder_
      }
      @discardableResult
      public func setPc(_ value:Tutorial.PerfCounter!) -> Tutorial.Event.Builder {
        self.pc = value
        return self
      }
      @discardableResult
      public func mergePc(value:Tutorial.PerfCounter) throws -> Tutorial.Event.Builder {
        if builderResult.hasPc {
          builderResult.pc = try Tutorial.PerfCounter.builderWithPrototype(prototype:builderResult.pc).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.pc = value
        }
        builderResult.hasPc = true
        return self
      }
      @discardableResult
      public func clearPc() -> Tutorial.Event.Builder {
        pcBuilder_ = nil
        builderResult.hasPc = false
        builderResult.pc = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Tutorial.Event.Builder {
        builderResult = Tutorial.Event()
        return self
      }
      override public func clone() throws -> Tutorial.Event.Builder {
        return try Tutorial.Event.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Tutorial.Event {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Tutorial.Event {
        let returnMe:Tutorial.Event = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Tutorial.Event) throws -> Tutorial.Event.Builder {
        if other == Tutorial.Event() {
         return self
        }
        if other.hasCreated {
             created = other.created
        }
        if other.hasSource {
             source = other.source
        }
        if other.hasInstance {
             instance = other.instance
        }
        if (other.hasKa) {
            try mergeKa(value: other.ka)
        }
        if (other.hasLg) {
            try mergeLg(value: other.lg)
        }
        if (other.hasPc) {
            try mergePc(value: other.pc)
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tutorial.Event.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.Event.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            created = try codedInputStream.readSInt64()

          case 18:
            source = try codedInputStream.readString()

          case 26:
            instance = try codedInputStream.readString()

          case 34:
            let subBuilder:Tutorial.KeepAlive.Builder = Tutorial.KeepAlive.Builder()
            if hasKa {
              try subBuilder.mergeFrom(other: ka)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            ka = subBuilder.buildPartial()

          case 42:
            let subBuilder:Tutorial.Log.Builder = Tutorial.Log.Builder()
            if hasLg {
              try subBuilder.mergeFrom(other: lg)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            lg = subBuilder.buildPartial()

          case 50:
            let subBuilder:Tutorial.PerfCounter.Builder = Tutorial.PerfCounter.Builder()
            if hasPc {
              try subBuilder.mergeFrom(other: pc)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            pc = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tutorial.Event.Builder {
        let resultDecodedBuilder = Tutorial.Event.Builder()
        if let jsonValueCreated = jsonMap["created"] as? String {
          resultDecodedBuilder.created = Int64(jsonValueCreated)!
        }
        if let jsonValueSource = jsonMap["source"] as? String {
          resultDecodedBuilder.source = jsonValueSource
        }
        if let jsonValueInstance = jsonMap["instance"] as? String {
          resultDecodedBuilder.instance = jsonValueInstance
        }
        if let jsonValueKa = jsonMap["ka"] as? Dictionary<String,Any> {
          resultDecodedBuilder.ka = try Tutorial.KeepAlive.Builder.decodeToBuilder(jsonMap:jsonValueKa).build()

        }
        if let jsonValueLg = jsonMap["lg"] as? Dictionary<String,Any> {
          resultDecodedBuilder.lg = try Tutorial.Log.Builder.decodeToBuilder(jsonMap:jsonValueLg).build()

        }
        if let jsonValuePc = jsonMap["pc"] as? Dictionary<String,Any> {
          resultDecodedBuilder.pc = try Tutorial.PerfCounter.Builder.decodeToBuilder(jsonMap:jsonValuePc).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Tutorial.Event.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Tutorial.Event.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class KeepAlive : GeneratedMessage {

    public static func == (lhs: Tutorial.KeepAlive, rhs: Tutorial.KeepAlive) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasInterval == rhs.hasInterval) && (!lhs.hasInterval || lhs.interval == rhs.interval)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var interval:UInt32 = UInt32(0)
    public fileprivate(set) var hasInterval:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasInterval {
        try codedOutputStream.writeUInt32(fieldNumber: 1, value:interval)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasInterval {
        serialize_size += interval.computeUInt32Size(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Tutorial.KeepAlive.Builder {
      return Tutorial.KeepAlive.classBuilder() as! Tutorial.KeepAlive.Builder
    }
    public func getBuilder() -> Tutorial.KeepAlive.Builder {
      return classBuilder() as! Tutorial.KeepAlive.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Tutorial.KeepAlive.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Tutorial.KeepAlive.Builder()
    }
    public func toBuilder() throws -> Tutorial.KeepAlive.Builder {
      return try Tutorial.KeepAlive.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Tutorial.KeepAlive) throws -> Tutorial.KeepAlive.Builder {
      return try Tutorial.KeepAlive.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasInterval {
        jsonMap["interval"] = UInt(interval)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tutorial.KeepAlive {
      return try Tutorial.KeepAlive.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Tutorial.KeepAlive {
      return try Tutorial.KeepAlive.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasInterval {
        output += "\(indent) interval: \(interval) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasInterval {
               hashCode = (hashCode &* 31) &+ interval.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Tutorial.KeepAlive"
    }
    override public func className() -> String {
        return "Tutorial.KeepAlive"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Tutorial.KeepAlive = Tutorial.KeepAlive()
      public func getMessage() -> Tutorial.KeepAlive {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasInterval:Bool {
           get {
                return builderResult.hasInterval
           }
      }
      public var interval:UInt32 {
           get {
                return builderResult.interval
           }
           set (value) {
               builderResult.hasInterval = true
               builderResult.interval = value
           }
      }
      @discardableResult
      public func setInterval(_ value:UInt32) -> Tutorial.KeepAlive.Builder {
        self.interval = value
        return self
      }
      @discardableResult
      public func clearInterval() -> Tutorial.KeepAlive.Builder{
           builderResult.hasInterval = false
           builderResult.interval = UInt32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Tutorial.KeepAlive.Builder {
        builderResult = Tutorial.KeepAlive()
        return self
      }
      override public func clone() throws -> Tutorial.KeepAlive.Builder {
        return try Tutorial.KeepAlive.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Tutorial.KeepAlive {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Tutorial.KeepAlive {
        let returnMe:Tutorial.KeepAlive = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Tutorial.KeepAlive) throws -> Tutorial.KeepAlive.Builder {
        if other == Tutorial.KeepAlive() {
         return self
        }
        if other.hasInterval {
             interval = other.interval
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tutorial.KeepAlive.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.KeepAlive.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            interval = try codedInputStream.readUInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tutorial.KeepAlive.Builder {
        let resultDecodedBuilder = Tutorial.KeepAlive.Builder()
        if let jsonValueInterval = jsonMap["interval"] as? UInt {
          resultDecodedBuilder.interval = UInt32(jsonValueInterval)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Tutorial.KeepAlive.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Tutorial.KeepAlive.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class Log : GeneratedMessage {

    public static func == (lhs: Tutorial.Log, rhs: Tutorial.Log) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasLevel == rhs.hasLevel) && (!lhs.hasLevel || lhs.level == rhs.level)
      fieldCheck = fieldCheck && (lhs.hasSeverity == rhs.hasSeverity) && (!lhs.hasSeverity || lhs.severity == rhs.severity)
      fieldCheck = fieldCheck && (lhs.hasFormat == rhs.hasFormat) && (!lhs.hasFormat || lhs.format == rhs.format)
      fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
      fieldCheck = fieldCheck && (lhs.hasTags == rhs.hasTags) && (!lhs.hasTags || lhs.tags == rhs.tags)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var level:Tutorial.LevelType = Tutorial.LevelType.system
    public fileprivate(set) var hasLevel:Bool = false
    public fileprivate(set) var severity:Tutorial.SeverityType = Tutorial.SeverityType.fatal
    public fileprivate(set) var hasSeverity:Bool = false
    public fileprivate(set) var format:Tutorial.FormatType = Tutorial.FormatType.plain
    public fileprivate(set) var hasFormat:Bool = false
    public fileprivate(set) var body:String = ""
    public fileprivate(set) var hasBody:Bool = false

    // users tags or categories
    public fileprivate(set) var tags:String = ""
    public fileprivate(set) var hasTags:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasLevel {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:level.rawValue)
      }
      if hasSeverity {
        try codedOutputStream.writeEnum(fieldNumber: 2, value:severity.rawValue)
      }
      if hasFormat {
        try codedOutputStream.writeEnum(fieldNumber: 3, value:format.rawValue)
      }
      if hasBody {
        try codedOutputStream.writeString(fieldNumber: 4, value:body)
      }
      if hasTags {
        try codedOutputStream.writeString(fieldNumber: 5, value:tags)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasLevel) {
        serialize_size += level.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if (hasSeverity) {
        serialize_size += severity.rawValue.computeEnumSize(fieldNumber: 2)
      }
      if (hasFormat) {
        serialize_size += format.rawValue.computeEnumSize(fieldNumber: 3)
      }
      if hasBody {
        serialize_size += body.computeStringSize(fieldNumber: 4)
      }
      if hasTags {
        serialize_size += tags.computeStringSize(fieldNumber: 5)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Tutorial.Log.Builder {
      return Tutorial.Log.classBuilder() as! Tutorial.Log.Builder
    }
    public func getBuilder() -> Tutorial.Log.Builder {
      return classBuilder() as! Tutorial.Log.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Tutorial.Log.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Tutorial.Log.Builder()
    }
    public func toBuilder() throws -> Tutorial.Log.Builder {
      return try Tutorial.Log.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Tutorial.Log) throws -> Tutorial.Log.Builder {
      return try Tutorial.Log.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasLevel {
        jsonMap["level"] = level.toString()
      }
      if hasSeverity {
        jsonMap["severity"] = severity.toString()
      }
      if hasFormat {
        jsonMap["format"] = format.toString()
      }
      if hasBody {
        jsonMap["body"] = body
      }
      if hasTags {
        jsonMap["tags"] = tags
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tutorial.Log {
      return try Tutorial.Log.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Tutorial.Log {
      return try Tutorial.Log.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasLevel) {
        output += "\(indent) level: \(level.description)\n"
      }
      if (hasSeverity) {
        output += "\(indent) severity: \(severity.description)\n"
      }
      if (hasFormat) {
        output += "\(indent) format: \(format.description)\n"
      }
      if hasBody {
        output += "\(indent) body: \(body) \n"
      }
      if hasTags {
        output += "\(indent) tags: \(tags) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasLevel {
               hashCode = (hashCode &* 31) &+ Int(level.rawValue)
            }
            if hasSeverity {
               hashCode = (hashCode &* 31) &+ Int(severity.rawValue)
            }
            if hasFormat {
               hashCode = (hashCode &* 31) &+ Int(format.rawValue)
            }
            if hasBody {
               hashCode = (hashCode &* 31) &+ body.hashValue
            }
            if hasTags {
               hashCode = (hashCode &* 31) &+ tags.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Tutorial.Log"
    }
    override public func className() -> String {
        return "Tutorial.Log"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Tutorial.Log = Tutorial.Log()
      public func getMessage() -> Tutorial.Log {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasLevel:Bool{
            get {
                return builderResult.hasLevel
            }
        }
        public var level:Tutorial.LevelType {
            get {
                return builderResult.level
            }
            set (value) {
                builderResult.hasLevel = true
                builderResult.level = value
            }
        }
      @discardableResult
        public func setLevel(_ value:Tutorial.LevelType) -> Tutorial.Log.Builder {
          self.level = value
          return self
        }
      @discardableResult
        public func clearLevel() -> Tutorial.Log.Builder {
           builderResult.hasLevel = false
           builderResult.level = .system
           return self
        }
        public var hasSeverity:Bool{
            get {
                return builderResult.hasSeverity
            }
        }
        public var severity:Tutorial.SeverityType {
            get {
                return builderResult.severity
            }
            set (value) {
                builderResult.hasSeverity = true
                builderResult.severity = value
            }
        }
      @discardableResult
        public func setSeverity(_ value:Tutorial.SeverityType) -> Tutorial.Log.Builder {
          self.severity = value
          return self
        }
      @discardableResult
        public func clearSeverity() -> Tutorial.Log.Builder {
           builderResult.hasSeverity = false
           builderResult.severity = .fatal
           return self
        }
        public var hasFormat:Bool{
            get {
                return builderResult.hasFormat
            }
        }
        public var format:Tutorial.FormatType {
            get {
                return builderResult.format
            }
            set (value) {
                builderResult.hasFormat = true
                builderResult.format = value
            }
        }
      @discardableResult
        public func setFormat(_ value:Tutorial.FormatType) -> Tutorial.Log.Builder {
          self.format = value
          return self
        }
      @discardableResult
        public func clearFormat() -> Tutorial.Log.Builder {
           builderResult.hasFormat = false
           builderResult.format = .plain
           return self
        }
      public var hasBody:Bool {
           get {
                return builderResult.hasBody
           }
      }
      public var body:String {
           get {
                return builderResult.body
           }
           set (value) {
               builderResult.hasBody = true
               builderResult.body = value
           }
      }
      @discardableResult
      public func setBody(_ value:String) -> Tutorial.Log.Builder {
        self.body = value
        return self
      }
      @discardableResult
      public func clearBody() -> Tutorial.Log.Builder{
           builderResult.hasBody = false
           builderResult.body = ""
           return self
      }
      public var hasTags:Bool {
           get {
                return builderResult.hasTags
           }
      }
      public var tags:String {
           get {
                return builderResult.tags
           }
           set (value) {
               builderResult.hasTags = true
               builderResult.tags = value
           }
      }
      @discardableResult
      public func setTags(_ value:String) -> Tutorial.Log.Builder {
        self.tags = value
        return self
      }
      @discardableResult
      public func clearTags() -> Tutorial.Log.Builder{
           builderResult.hasTags = false
           builderResult.tags = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Tutorial.Log.Builder {
        builderResult = Tutorial.Log()
        return self
      }
      override public func clone() throws -> Tutorial.Log.Builder {
        return try Tutorial.Log.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Tutorial.Log {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Tutorial.Log {
        let returnMe:Tutorial.Log = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Tutorial.Log) throws -> Tutorial.Log.Builder {
        if other == Tutorial.Log() {
         return self
        }
        if other.hasLevel {
             level = other.level
        }
        if other.hasSeverity {
             severity = other.severity
        }
        if other.hasFormat {
             format = other.format
        }
        if other.hasBody {
             body = other.body
        }
        if other.hasTags {
             tags = other.tags
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tutorial.Log.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.Log.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntlevel = try codedInputStream.readEnum()
            if let enumslevel = Tutorial.LevelType(rawValue:valueIntlevel){
                 level = enumslevel
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntlevel))
            }

          case 16:
            let valueIntseverity = try codedInputStream.readEnum()
            if let enumsseverity = Tutorial.SeverityType(rawValue:valueIntseverity){
                 severity = enumsseverity
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntseverity))
            }

          case 24:
            let valueIntformat = try codedInputStream.readEnum()
            if let enumsformat = Tutorial.FormatType(rawValue:valueIntformat){
                 format = enumsformat
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntformat))
            }

          case 34:
            body = try codedInputStream.readString()

          case 42:
            tags = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tutorial.Log.Builder {
        let resultDecodedBuilder = Tutorial.Log.Builder()
        if let jsonValueLevel = jsonMap["level"] as? String {
          resultDecodedBuilder.level = try Tutorial.LevelType.fromString(str: jsonValueLevel)
        }
        if let jsonValueSeverity = jsonMap["severity"] as? String {
          resultDecodedBuilder.severity = try Tutorial.SeverityType.fromString(str: jsonValueSeverity)
        }
        if let jsonValueFormat = jsonMap["format"] as? String {
          resultDecodedBuilder.format = try Tutorial.FormatType.fromString(str: jsonValueFormat)
        }
        if let jsonValueBody = jsonMap["body"] as? String {
          resultDecodedBuilder.body = jsonValueBody
        }
        if let jsonValueTags = jsonMap["tags"] as? String {
          resultDecodedBuilder.tags = jsonValueTags
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Tutorial.Log.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Tutorial.Log.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PerfCounter : GeneratedMessage {

    public static func == (lhs: Tutorial.PerfCounter, rhs: Tutorial.PerfCounter) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Tutorial.PerfCounter.Builder {
      return Tutorial.PerfCounter.classBuilder() as! Tutorial.PerfCounter.Builder
    }
    public func getBuilder() -> Tutorial.PerfCounter.Builder {
      return classBuilder() as! Tutorial.PerfCounter.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Tutorial.PerfCounter.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Tutorial.PerfCounter.Builder()
    }
    public func toBuilder() throws -> Tutorial.PerfCounter.Builder {
      return try Tutorial.PerfCounter.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Tutorial.PerfCounter) throws -> Tutorial.PerfCounter.Builder {
      return try Tutorial.PerfCounter.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tutorial.PerfCounter {
      return try Tutorial.PerfCounter.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Tutorial.PerfCounter {
      return try Tutorial.PerfCounter.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Tutorial.PerfCounter"
    }
    override public func className() -> String {
        return "Tutorial.PerfCounter"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Tutorial.PerfCounter = Tutorial.PerfCounter()
      public func getMessage() -> Tutorial.PerfCounter {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Tutorial.PerfCounter.Builder {
        builderResult = Tutorial.PerfCounter()
        return self
      }
      override public func clone() throws -> Tutorial.PerfCounter.Builder {
        return try Tutorial.PerfCounter.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Tutorial.PerfCounter {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Tutorial.PerfCounter {
        let returnMe:Tutorial.PerfCounter = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Tutorial.PerfCounter) throws -> Tutorial.PerfCounter.Builder {
        if other == Tutorial.PerfCounter() {
         return self
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tutorial.PerfCounter.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.PerfCounter.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tutorial.PerfCounter.Builder {
        let resultDecodedBuilder = Tutorial.PerfCounter.Builder()
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Tutorial.PerfCounter.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Tutorial.PerfCounter.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

}
extension Tutorial.Event: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tutorial.Event> {
    var mergedArray = Array<Tutorial.Event>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tutorial.Event? {
    return try Tutorial.Event.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Tutorial.Event {
    return try Tutorial.Event.Builder().mergeFrom(data: data, extensionRegistry:Tutorial.MonikRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tutorial.Event {
    return try Tutorial.Event.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Tutorial.Event {
    return try Tutorial.Event.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.Event {
    return try Tutorial.Event.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tutorial.Event {
    return try Tutorial.Event.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.Event {
    return try Tutorial.Event.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Tutorial.KeepAlive: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tutorial.KeepAlive> {
    var mergedArray = Array<Tutorial.KeepAlive>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tutorial.KeepAlive? {
    return try Tutorial.KeepAlive.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Tutorial.KeepAlive {
    return try Tutorial.KeepAlive.Builder().mergeFrom(data: data, extensionRegistry:Tutorial.MonikRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tutorial.KeepAlive {
    return try Tutorial.KeepAlive.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Tutorial.KeepAlive {
    return try Tutorial.KeepAlive.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.KeepAlive {
    return try Tutorial.KeepAlive.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tutorial.KeepAlive {
    return try Tutorial.KeepAlive.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.KeepAlive {
    return try Tutorial.KeepAlive.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Tutorial.Log: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tutorial.Log> {
    var mergedArray = Array<Tutorial.Log>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tutorial.Log? {
    return try Tutorial.Log.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Tutorial.Log {
    return try Tutorial.Log.Builder().mergeFrom(data: data, extensionRegistry:Tutorial.MonikRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tutorial.Log {
    return try Tutorial.Log.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Tutorial.Log {
    return try Tutorial.Log.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.Log {
    return try Tutorial.Log.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tutorial.Log {
    return try Tutorial.Log.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.Log {
    return try Tutorial.Log.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Tutorial.PerfCounter: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tutorial.PerfCounter> {
    var mergedArray = Array<Tutorial.PerfCounter>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tutorial.PerfCounter? {
    return try Tutorial.PerfCounter.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Tutorial.PerfCounter {
    return try Tutorial.PerfCounter.Builder().mergeFrom(data: data, extensionRegistry:Tutorial.MonikRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tutorial.PerfCounter {
    return try Tutorial.PerfCounter.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Tutorial.PerfCounter {
    return try Tutorial.PerfCounter.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.PerfCounter {
    return try Tutorial.PerfCounter.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tutorial.PerfCounter {
    return try Tutorial.PerfCounter.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tutorial.PerfCounter {
    return try Tutorial.PerfCounter.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
